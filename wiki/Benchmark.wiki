#labels Deprecated
=== `HashIndex`: _Retrieve By Unique Key_ ===

Retrieve a single `Car` object from the collection based on `Car.carId` having value 500, which uniquely identifies a car. `HashIndex` on `Car.CAR_ID`.

This example demonstrates CQEngine's support for _constant_ retrieval time regardless of the size of the collection.

  * CQEngine query: `equal(Car.CAR_ID, 500)`
  * SQL equivalent: `SELECT * FROM cars WHERE carId = 500`

*Results*

  * CQEngine is *630488.48% faster* than naive iteration
  * CQEngine is *627369.75% faster* than optimized iteration

[http://cqengine.googlecode.com/svn/wiki/images/hash-index-unique-carid.png]

=== `HashIndex`: _Retrieve Manufacturer "Ford" (large result set)_ ===

Retrieve and iterate `Car` objects from the collection based on `Car.manufacturer` having value "`Ford`". `HashIndex` on `Car.MANUFACTURER`.

This query matches 30,000 cars; 30% of the collection of 100,000 cars. This benchmark example forces CQEngine to iterate all 30,000 cars, even though most applications would not require that many results. In contrast, the iteration approaches can _require_ the _entire_ collection to be iterated, because matching results could be located towards the end of the collection. CQEngine `ResultSet`s intentionally support _paging_ through results, and due to _lazy evaluation_, if the application stops iterating, no unnecessary computations would have been performed. This example is nonetheless to demonstrate CQEngine's performance when a large fraction of the collection is requested and processed.

  * CQEngine query: `equal(Car.MANUFACTURER, "Ford")`
  * SQL equivalent: `SELECT * FROM cars WHERE manufacturer = 'Ford'`

*Results*

  * CQEngine is *423.17% faster* than naive iteration
  * CQEngine is *241.83% faster* than optimized iteration

[http://cqengine.googlecode.com/svn/wiki/images/hash-index-manufacturer-ford.png]

=== `HashIndex`: _Retrieve Model "Focus" (smaller result set)_ ===
Retrieve and iterate `Car` objects from the collection based on `Car.model` having value "`Focus`". `HashIndex` on `Car.MODEL`.

This query matches 10,000 cars; 10% of the collection of 100,000 cars. CQEngine is less severely penalised compared with the example above; nevertheless is is a large fraction. CQEngine outperforms iteration by a wider margin in this case.

  * CQEngine query: `equal(Car.MODEL, "Focus")`
  * SQL equivalent: `SELECT * FROM cars WHERE model = 'Focus'`

*Results*

  * CQEngine is *1627.06% faster* than naive iteration
  * CQEngine is *1324.17% faster* than optimized iteration

[http://cqengine.googlecode.com/svn/wiki/images/hash-index-model-focus.png]

=== `NavigableIndex`: _Retrieve Price Between_ ===

Retrieve and iterate `Car` objects from the collection based on `Car.price` being _greater than or equal to_ 3000.00 and _less than_ 4000.00. `NavigableIndex` on `Car.PRICE`.

  * CQEngine query: `between(Car.PRICE, 3000.0, true, 4000.0, false)`
    * _Note: true = inclusive, false = exclusive_
  * SQL equivalent: `SELECT * FROM cars WHERE price >= 3000.0 AND price < 4000.0`

*Results*

  * CQEngine is *506.08% faster* than naive iteration
  * CQEngine is *325.89% faster* than optimized iteration

[http://cqengine.googlecode.com/svn/wiki/images/navigable-index-price-between.png]

=== `RadixTreeIndex`: _Retrieve Models Starting With_ ===

Retrieve and iterate `Car` objects from the collection based on `Car.model` starting with "`P`". `RadixTreeIndex` on `Car.model`.

Note: See also `ReversedRadixTreeIndex` which supports _ends with_-type queries. It would have identical performance characteristics as this `RadixTreeIndex` so it was not benchmarked separately.

  * CQEngine query: `startsWith(Car.MODEL, "P")`
  * SQL equivalent: `SELECT * FROM cars WHERE model LIKE 'P%'`

*Results*

  * CQEngine is *1357.81% faster* than naive iteration
  * CQEngine is *1110.12% faster* than optimized iteration

[http://cqengine.googlecode.com/svn/wiki/images/radix-tree-index-model-starts-with-p.png]

=== `SuffixTreeIndex`: _Retrieve Models Containing_ ===

Retrieve and iterate `Car` objects from the collection based on `Car.model` containing "`g`". `SuffixTreeIndex` on `Car.model`.

  * CQEngine query: `contains(Car.MODEL, "g")`
  * SQL equivalent: `SELECT * FROM cars WHERE model LIKE '%g%'`

*Results*

  * CQEngine is *1860.53% faster* than naive iteration
  * CQEngine is *1605.31% faster* than optimized iteration

[http://cqengine.googlecode.com/svn/wiki/images/suffix-tree-index-model-contains-g.png]

=== Quantized `HashIndex`: _Retrieve By Unique Key_ ===

Retrieve a single `Car` object from the collection based on `Car.carId` having value 500, which uniquely identifies a car. _Quantized_ `HashIndex` on `Car.CAR_ID` with compression factor 5.

This example demonstrates the effect of _quantization_ on indexes. Quantization allows the _granularity_ of indexes to be controlled. In this example, the index was created with an `IntegerQuantizer` with compression factor 5. This means that every 5 consecutive `carId`s will be grouped together and stored as a single entry in the index. This reduces the _size_ of the index (reduces memory overhead) and trades it instead for slightly higher _CPU utilization_ during retrieval. The index will need to filter results retrieved from the entry _on-the-fly_, to ensure that they actually match the query.

  * CQEngine query: `equal(Car.CAR_ID, 501)`
  * SQL equivalent: `SELECT * FROM cars WHERE carId = 501`

*Results*

  * CQEngine is *481984.43% faster* than naive iteration
  * CQEngine is *467645.90% faster* than optimized iteration

[http://cqengine.googlecode.com/svn/wiki/images/quantized-hash-index-unique-carid.png]

=== Quantized `NavigableIndex`: _Retrieve !CarId Between_ ===

Retrieve three `Car` objects from the collection based on `Car.carId` having values between 500 and 502. _Quantized_ `NavigableIndex` on `Car.CAR_ID` with compression factor 5.

This example demonstrates that _quantization_ can be applied to navigable indexes, with minimal overhead on _range_-type queries. CQEngine applies _on-the-fly_ filtering only to quantized entries at the _start_ and/or _end_ of ranges.

  * CQEngine query: `between(Car.CAR_ID, 500, 502)`
  * SQL equivalent: `SELECT * FROM cars WHERE carId BETWEEN 500 AND 502`

*Results*

  * CQEngine is *330187.50% faster* than naive iteration
  * CQEngine is *325727.79% faster* than optimized iteration

[http://cqengine.googlecode.com/svn/wiki/images/quantized-navigable-index-carid-between.png]