#labels Deprecated
CQEngine is a NoSQL query engine for retrieving objects from Java collections using SQL-like queries, without iterating through the collection, and with response time in the order of _microseconds_.

CQEngine is somewhat similar to [hXXttp://code.google.com/p/lambdaj/ XXLambdaJ] or [http://en.wikipedia.org/wiki/Language_Integrated_Query Microsoft LINQ], but internally CQEngine uses indexing and query plan optimization rather than iteration to process queries.

== Iteration versus Indexing and Query Plan Optimization ==
=== Iteration ===
The classic way to retrieve objects matching some criteria from a collection, is to iterate through the collection and apply some tests to each object. If the object matches the criteria, then it is added to a result set. This is repeated for every object in the collection.

*Example: Perform a Query via Iteration*

This is hugely inefficient, it performs up to 20,000 tests, for a collection of 10,000 cars:
{{{
    public static Collection<Car> getBlueCarsWithFourDoors(Collection<Car> allCars) {
        List<Car> results = new LinkedList<Car>();
        for (Car car : allCars) {
            if (car.getColor().equals(Car.Color.BLUE) && car.getDoors() == 4) {
                results.add(car);
            }
        }
        return results;
    }
}}}
  * It should be clear that performing queries using iteration, is like _performing SQL queries on a database table which does not have any indexes_.

*Time Complexity*

Let number of objects in the collection = _n_. Let number of tests to be applied to each object = _t_. If there were 10,000 objects in the collection and 5 tests to apply to each object, performing the query would require _n_ x _t_ tests, or 50,000 tests in total.

For every _additional_ object added to the collection, _five_ additional tests would need to be performed. As such the performance of queries would _degrade steeply_ as additional objects were added. This is not scalable. The [http://en.wikipedia.org/wiki/Time_complexity time complexity] of this iteration approach (worst case) is O(_n_ _t_).

*In fact, the iteration above could be improved:*

  # If it was known that _fewer cars have 4 doors than are blue_, the test for number of doors should be performed _first_. That way, Java would short-circuit the `&&` operator and not actually test the color for the majority of cars which did not already have four doors.
  # In most situations, the application which calls this method, will just iterate through the results returned. In that respect, the method would have _allocated a `LinkedList` needlessly_. A further problem with the approach, is that it *causes latency*, because the _entire result set must be assembled before the first object can be processed_. The method could be further enhanced to accept a `Handler` object, which it would invoke supplying each Car object which matches the criteria. The handler could do whatever the application otherwise would have done inside its iteration loop; yet a `LinkedList` would not have been allocated, and additionally the first object would be processed as soon as it was encountered.
  # An even nicer way to avoid allocating a `LinkedList`, and which would allow the first object to be processed sooner, and yet which would still allow applications to iterate results in the normal way (without supplying a `Handler`), would be for the method to return an `Iterable` object which acted as a _filtered view_ over `allCars`. As the application iterated through the view, the `Iterable` would scan `allCars` for the _next_ matching object. This is known as _lazy evaluation_.

The problem with optimization #1, is that implementing it requires *statistical knowledge* of the makeup of the collection, based on the values of the fields within each `Car` object.
  * Fortunately, *CQEngine maintains statistical information* on the makeup of collections, and in fact will always re-order queries to maximize execution speed.
  * Also fortunately, *CQEngine uses _lazy evaluation_* heavily: the result sets returned by CQEngine are rarely _materialized_, and instead act as a _view_ over the set of objects in the collection which ultimately match the query.
  * Of course, the main problem with the approach above, is that it *uses iteration in the first place*. It would be useful if it could somehow _jump_ to the sets of cars which have four doors, or which are blue, or both, without having to scan the collection at all.

=== Indexing and Query Plan Optimization in CQEngine ===
In CQEngine, it is possible to build indexes on the fields of the objects stored in a collection. For example, if many queries retrieve cars from a collection of `Car` objects, based on the value of field `Car.color`, an index could be added on `Car.color`. Subsequently CQEngine could retrieve the set of objects matching any given color _immediately_ with _constant time complexity_ O(1). No iteration would be necessary, and performance would not degrade as new cars were added to the collection.

In CQEngine:
  * *Simple Indexes* can be added to any number of individual fields in a collection of objects, allowing queries on just those fields to be answered in O(1) time complexity
  * *Multiple indexes can be added to the same field*  - several index implementations are provided, each optimized for different types of query on the same field - for example equality, numerical range, string starts with etc.
  * *Compound Indexes* can be added which span multiple fields, allowing queries referencing several fields to also be answered in O(1) time complexity
  * *Standing Query Indexes* can be added; these allow _arbitrarily complex queries_ to be answered in O(1) time complexity, regardless of the number of fields referenced
  * *Query Plan Optimization* - when several fields have suitable indexes, CQEngine will use statistical information from the indexes, to internally make a query plan which selects the indexes which can perform the query with minimum time complexity. When some referenced fields have suitable indexes and some do not, CQEngine will use the available indexes first, and will then iterate the smallest possible set of results from those indexes to filter objects for the rest of the query
  * *Iteration fallback* -  if no suitable indexes are available, CQEngine will evaluate the query via iteration. CQEngine can always evaluate every query, even if no suitable indexes are available. Queries are not coupled with indexes, so indexes can be added after the fact, to speed up existing queries
  * *CQEngine supports full concurrency* and expects that objects will be added to and removed from the collection at runtime; CQEngine will take care of updating all registered indexes in realtime, without impacting the performance of reading threads while updates are taking place

*Example: Perform a Query via CQEngine*
{{{
import static com.googlecode.cqengine.query.QueryFactory.*;
...
    public static ResultSet<Car> getBlueCarsWithFourDoors(IndexedCollection<Car> allCars) {
        Query<Car> blueCarsWithFourDoors = and(
                equal(Car.COLOR, Car.Color.BLUE),
                equal(Car.DOORS, 4)
        );
        return allCars.retrieve(blueCarsWithFourDoors);
    }
}}}

== Performance and Time Complexity ==
To compare the performance of CQEngine versus iteration, let's consider an example.

Let's assume we have an online car dealership. The dealership has a website with a catalogue of 100,000 cars. So it has a collection of `Car` objects. Every car object has a number of fields containing the price, manufacturer, model, number of doors etc. For the purpose of the example, let's ignore setter and getter methods, and assume Cars are immutable.
{{{
public class Car {
    enum Color {RED, GREEN, BLUE, BLACK, WHITE}
    public final int carId;
    public final String manufacturer;
    public final String model;
    public final Color color;
    public final int doors;
    public final double price;

    public Car(int carId, String manufacturer, String model, Color color, int doors, double price) {
        this.carId = carId;
        this.manufacturer = manufacturer;
        this.model = model;
        this.color = color;
        this.doors = doors;
        this.price = price;
    }
}
}}}

For the sake of the example, let's say the collection of Cars is created by the following method:
{{{
    public static Set<Car> createCollectionOfCars(int numCars) {
        Set<Car> cars = new LinkedHashSet<Car>(numCars);
        for (int carId = 0; carId < numCars; carId++) {
            final Car car;
            switch (carId % 10) {
                case 0: car = new Car(carId, "Ford",   "Focus",   Car.Color.RED,   5, 5000.00); break;
                case 1: car = new Car(carId, "Ford",   "Fusion",  Car.Color.RED,   4, 3999.99); break;                    
                case 2: car = new Car(carId, "Ford",   "Taurus",  Car.Color.GREEN, 4, 6000.00); break;                    
                case 3: car = new Car(carId, "Honda",  "Civic",   Car.Color.WHITE, 5, 4000.00); break;                    
                case 4: car = new Car(carId, "Honda",  "Accord",  Car.Color.BLACK, 5, 3000.00); break;                    
                case 5: car = new Car(carId, "Honda",  "Insight", Car.Color.GREEN, 3, 5000.00); break;                    
                case 6: car = new Car(carId, "Toyota", "Avensis", Car.Color.GREEN, 5, 5999.95); break;                    
                case 7: car = new Car(carId, "Toyota", "Prius",   Car.Color.BLUE,  3, 8500.00); break;                    
                case 8: car = new Car(carId, "Toyota", "Hilux",   Car.Color.RED,   5, 7800.55); break;                    
                case 9: car = new Car(carId, "BMW",    "M6",      Car.Color.BLUE,  2, 9000.23); break;                    
                default: throw new IllegalStateException();
            }
            cars.add(car);
        }
        return cars;
    }
}}}

As such, some statistics about the collection:
|| *Color (aka Colour :)* || *% of cars* || *Manufacturer* || *% of cars* || *Number of doors* || *% of cars* ||
|| Red || 30% || Ford || 30% || 5 || 50% ||
|| Green || 30% || Honda || 30% || 4 || 20% ||
|| Blue || 20% || Toyota || 30% || 3 || 20% ||
|| Black || 10% || BMW || 10% || 2 || 10% ||
|| White || 10% ||  ||  || || ||


|| Cars which are green and are manufactured by Ford || 10% ||
|| Cars which are blue and have 3 doors || 10% ||