#labels Deprecated
CQEngine, Collection Query Engine, is a NoSQL query engine for retrieving objects from Java collections using SQL-like queries, without the overhead of iterating through the collection. Response times are in the order of microseconds.

CQEngine is also easier to use than writing code for conventional iteration; most queries can be written in one line of code.

CQEngine is somewhat similar to [hXXttp://code.google.com/p/lambdaj/ XXLambdaJ] or [http://en.wikipedia.org/wiki/Language_Integrated_Query Microsoft LINQ], but internally it uses indexes, set theory and query plan optimization to process queries, to instead _avoid_ iterating through the collection.

<wiki:toc max_depth="3" />

== The Limits of Iteration ==
The classic way to retrieve objects matching some criteria from a collection, is to iterate through the collection and apply some tests to each object. If the object matches the criteria, then it is added to a result set. This is repeated for every object in the collection.

Conventional iteration is hugely inefficient, with time complexity O(_n_ _t_). However it can be optimized: [TheLimitsOfIteration Read more]

*Benchmark Sneak Peek*

Even with optimizations applied to convention iteration, CQEngine can outperform conventional iteration by wide margins. Here is a graph of a test comparing CQEngine latency with iteration for a range-type query:

[http://cqengine.googlecode.com/svn/wiki/images/quantized-navigable-index-carid-between.png]

  * CQEngine is *330187.50% faster* than naive iteration
  * CQEngine is *325727.79% faster* than optimized iteration

See the [Benchmark] wiki page for details of this test, and other tests with various types of query.

== CQEngine Overview ==

CQEngine solves the scalability and latency problems of iteration by making it possible to build _indexes_ on the fields of the objects stored in a collection. For example, if many queries retrieve cars from a collection of `Car` objects, based on the value of field `Car.color`, an index could be added on `Car.color`. Subsequently CQEngine could retrieve the set of objects matching any given color _immediately_ with _constant time complexity_ O(_1_). No iteration would be necessary, and performance would not degrade as new cars were added to the collection. CQEngine is additionally programmed with the rules of set theory, allowing it to reorder components of queries to generate efficient query plans.

*Indexing and Query Plan Optimization*

  * *Simple Indexes* can be added to any number of individual fields in a collection of objects, allowing queries on just those fields to be answered in O(_1_) time complexity
  * *Multiple indexes on the same field*  - several index implementations are provided, each optimized for different types of query on the same field - for example equality, numerical range, string starts with etc.
  * *Compound Indexes* can be added which span multiple fields, allowing queries referencing several fields to also be answered in O(_1_) time complexity
  * *Nested Queries* are fully supported, such as the SQL equivalent of "`WHERE color = 'blue' AND(NOT(doors = 2 OR price > 53.00))`"
  * *Standing Query Indexes* can be added; these allow _arbitrarily complex queries_, or _nested query fragments_, to be answered in O(_1_) time complexity, regardless of the number of fields referenced. Large queries containing branches or query fragments for which standing query indexes exist, will automatically benefit from O(_1_) time complexity evaluation of their branches; in total several indexes might be used to accelerate complex queries
  * *Statistical Query Plan Optimization* - when several fields have suitable indexes, CQEngine will use statistical information from the indexes, to internally make a query plan which selects the indexes which can perform the query with minimum time complexity. When some referenced fields have suitable indexes and some do not, CQEngine will use the available indexes first, and will then iterate the smallest possible set of results from those indexes to filter objects for the rest of the query. In those cases time complexity will be greater than O(_1_), but usually significantly less than O(_n_)
  * *Iteration fallback* -  if no suitable indexes are available, CQEngine will evaluate the query via iteration, using lazy evaluation. CQEngine can always evaluate every query, even if no suitable indexes are available. Queries are not coupled with indexes, so indexes can be added after the fact, to speed up existing queries
  * *CQEngine supports full concurrency* and expects that objects will be added to and removed from the collection at runtime; CQEngine will take care of updating all registered indexes in realtime, without impacting the performance of reading threads while updates are taking place. All provided indexes support *lock-free reads*
  * *Type-safe* - nearly all errors in queries result in _compile-time_ errors instead of exceptions at runtime: CQEngine, all indexes, and all queries are strongly typed using generics at both object-level and field-level

== Feature Matrix for Included Indexes ==

*Legend for the feature matrix*

|| *Abbreviation* || *Meaning* || *Example* ||
|| *EQ* || _Equality_ || `equal(Car.DOORS, 4)` ||
|| *IN* || _Equality, multiple values_ || `in(Car.DOORS, 3, 4, 5)` ||
|| *LT* || _Less Than (numerical range / `Comparable`)_ || `lessThan(Car.PRICE, 5000.0)` ||
|| *GT* || _Greater Than (numerical range / `Comparable`)_ || `greaterThan(Car.PRICE, 2000.0)` ||
|| *BT* || _Between (numerical range / `Comparable`)_ || `between(Car.PRICE, 2000.0, 5000.0)` ||
|| *SW* || _String Starts With_ || `startsWith(Car.NAME, "For")` ||
|| *EW* || _String Ends With_ || `endsWith(Car.NAME, "ord")` ||
|| *SC* || _String Contains_ || `contains(Car.NAME, "or")` ||
|| *CI* || _String Is Contained In_ || `isContainedIn(Car.NAME, "I am shopping for a Ford Focus car")` ||
|| *SQ* || _Standing Query_ || _Build an index to provide constant time complexity for an entire query_ ||
|| *QZ* || _Quantization_ || _Does the index accept a quantizer to control granularity_ ||

*Index Feature Matrix*
|| *Index Type* || *EQ* || *IN* || *LT* || *GT* || *BT* || *SW* || *EW* || *SC* || *CI* || *SQ* || *QZ* ||
|| [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/index/hash/HashIndex.html Hash] || ✓ || ✓ ||  ||  ||  ||  ||  ||  ||  ||  || ✓ ||
|| [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/index/compound/CompoundIndex.html Compound] || ✓ || ✓ ||  ||  ||  ||  ||  ||  ||  ||  || ✓ ||
|| [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/index/navigable/NavigableIndex.html Navigable] || ✓ || ✓ || ✓ || ✓ || ✓ ||  ||  ||  ||  ||  || ✓ ||
|| [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/index/radix/RadixTreeIndex.html RadixTree] || ✓ || ✓ ||  ||  ||  || ✓ ||  ||  ||  ||  ||  ||
|| [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/index/radixreversed/ReversedRadixTreeIndex.html ReversedRadixTree] || ✓ || ✓ ||  ||  ||  ||  || ✓ ||  ||  ||  ||  ||
|| [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/index/radixinverted/InvertedRadixTreeIndex.html InvertedRadixTree] || ✓ || ✓ ||  ||  ||  ||  ||  ||  || ✓ ||  ||  ||
|| [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/index/suffix/SuffixTreeIndex.html SuffixTree] || ✓ || ✓ ||  ||  ||  ||  || ✓ || ✓ ||  ||  ||  ||
|| [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/index/standingquery/StandingQueryIndex.html StandingQuery] ||  ||  ||  ||  ||  ||  ||  ||  ||  || ✓ ||  ||
|| [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/index/fallback/FallbackIndex.html Fallback] || ✓ || ✓ || ✓ || ✓ || ✓ || ✓ || ✓ || ✓ || ✓ ||  ||  ||


== Complete Example ===

In CQEngine applications mostly interact with [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/IndexedCollection.html IndexedCollection], which is an implementation of [http://docs.oracle.com/javase/6/docs/api/java/util/Set.html java.util.Set], and it provides two additional methods:

  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/engine/QueryEngine.html#addIndex(com.googlecode.cqengine.index.Index) addIndex(SomeIndex)] allows indexes to be added to the collection
  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/engine/QueryEngine.html#retrieve(com.googlecode.cqengine.query.Query) retrieve(Query)] accepts a [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/query/Query.html Query] and returns a [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html ResultSet] providing objects matching that query. `ResultSet` implements [http://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html java.lang.Iterable], so accessing results is achieved by iterating the result set

Here is a *complete example* of how to build a collection, add indexes and perform queries. It does not discuss _attributes_, which are discussed below.
{{{
import static com.googlecode.cqengine.query.QueryFactory.*;

public class Introduction {

    public static void main(String[] args) {
        // Create an indexed collection (note: could alternatively use CQEngine.copyFrom() existing collection)...
        IndexedCollection<Car> cars = CQEngine.newInstance();

        // Add some indexes...
        cars.addIndex(NavigableIndex.onAttribute(Car.CAR_ID));
        cars.addIndex(ReversedRadixTreeIndex.onAttribute(Car.NAME));
        cars.addIndex(SuffixTreeIndex.onAttribute(Car.DESCRIPTION));
        cars.addIndex(HashIndex.onAttribute(Car.FEATURES));

        // Add some objects to the collection...
        cars.add(new Car(1, "ford focus", "great condition, low mileage", Arrays.asList("spare tyre", "sunroof")));
        cars.add(new Car(2, "ford taurus", "dirty and unreliable, flat tyre", Arrays.asList("spare tyre", "radio")));
        cars.add(new Car(3, "honda civic", "has a flat tyre and high mileage", Arrays.asList("radio")));

        // -------------------------- Run some queries --------------------------
        System.out.println("Cars whose name ends with 'vic' or whose id is less than 2:");
        Query<Car> query1 = or(endsWith(Car.NAME, "vic"), lessThan(Car.CAR_ID, 2));
        for (Car car : cars.retrieve(query1)) {
            System.out.println(car);
        }

        System.out.println("\nCars whose flat tyre can be replaced:");
        Query<Car> query2 = and(contains(Car.DESCRIPTION, "flat tyre"), equal(Car.FEATURES, "spare tyre"));
        for (Car car : cars.retrieve(query2)) {
            System.out.println(car);
        }

        System.out.println("\nCars which have a sunroof or a radio but are not dirty:");
        Query<Car> query3 = and(in(Car.FEATURES, "sunroof", "radio"), not(contains(Car.DESCRIPTION, "dirty")));
        for (Car car : cars.retrieve(query3)) {
            System.out.println(car);
        }
    }
}
}}}

*Output from the example*

  * _Cars whose name ends with 'vic' or whose id is less than 2:_
{{{
Car{carId=3, name='honda civic', description='has a flat tyre and high mileage', features=[radio]}
Car{carId=1, name='ford focus', description='great condition, low mileage', features=[spare tyre, sunroof]}
}}}

  * _Cars whose flat tyre can be replaced:_
{{{
Car{carId=2, name='ford taurus', description='dirty and unreliable, flat tyre', features=[spare tyre, radio]}
}}}

  * _Cars which have a sunroof or a radio but are not dirty:_
{{{
Car{carId=1, name='ford focus', description='great condition, low mileage', features=[spare tyre, sunroof]}
Car{carId=3, name='honda civic', description='has a flat tyre and high mileage', features=[radio]}
}}}

== Attributes to Read Fields ==

CQEngine needs to access fields inside objects, so that it can build indexes on fields, and retrieve the value of a certain field from any given object.

CQEngine does not use reflection to do this; instead it uses *attributes*, which is a more powerful concept. An attribute is an object which can read the value of a certain field given an object.

Here is an example of how to define an attribute for a Car object, which reads the `Car.carId` field:
{{{
    public static final Attribute<Car, Integer> CAR_ID = new SimpleAttribute<Car, Integer>("carId") {
        public Integer getValue(Car car) { return car.carId; }
    };
}}}
Usually attributes are defined as anonymous `static` `final` objects like this. Supplying the `"carId"` string parameter to the constructor is actually optional, it is not used by the query engine per-se, except it will lead to more informative exception messages.

Since this attribute reads a field from a `Car` object, the usual place to put the attribute is inside the `Car` class - and this makes queries more readable. However it could really be defined in any class, such as `CarAttributes` or similar. The example above is for a *[http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/attribute/SimpleAttribute.html SimpleAttribute]*, which is designed for fields containing only one value.

CQEngine also supports another type of attribute - *[http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/attribute/MultiValueAttribute.html MultiValueAttribute]* - which can read the values of fields which themselves are collections, and so supports building indexes on objects based on things like keywords associated with those objects.

Here is an example of how to define a `MultiValueAttribute` for a `Car` object which reads the values from `Car.features` where that field is a `List<String>`:
{{{
    public static final Attribute<Car, String> FEATURES = new MultiValueAttribute<Car, String>("features") {
        public List<String> getValues(Car car) { return car.features; }
    };
}}}

== Attributes as Functions ==

It can be noted that attributes are only required to return a value given an object. Although most will do so, there is no requirement that an attribute must provide a value by reading a field in the object. As such attributes can be _virtual_, implemented as _functions_.

*Calculated Attributes*

An attribute can *_calculate_* an appropriate value for an object, based on a function applied to data contained in other fields or from external data sources.

Here is an example for a calculated attribute:
{{{
    public static final Attribute<Car, Boolean> IS_DIRTY = new SimpleAttribute<Car, Boolean>("is_dirty") {
        public Boolean getValue(Car car) { return car.description.contains("dirty"); }
    };
}}}

A `HashIndex` could be built on the virtual attribute above, which would enable fast retrievals of cars which are either dirty or not dirty, without needing to scan the collection.

*Associations with other `IndexedCollections` or External Data Sources*

Here is an example for a virtual attribute which *associates* with each `Car` a list of locations which can service it, from an external data source:
{{{
    public static final Attribute<Car, String> SERVICE_LOCATIONS = new MultiValueAttribute<Car, String>() {
        public List<String> getValues(Car car) {
            return CarServiceManager.getServiceLocationsForCar(car);
        }
    };
}}}
The attribute above would allow the `IndexedCollection` of cars to be searched for cars which have _servicing options in a particular location_.

The locations which service a car, could alternatively be retrieved from another `IndexedCollection`, of `Garage`s, for example. *Care should be taken if building indexes on virtual attributes* however, if referenced data might change leaving obsolete information in indexes. A *strategy to accommodate this* is: if no index exists for a virtual attribute referenced in a query, and other attributes are also referenced in the query for which indexes exist, CQEngine will automatically reduce the candidate set of objects to the minimum using other indexes before querying the virtual attribute. In turn if virtual attributes perform retrievals from _other_ `IndexedCollection`s, then those collections could be indexed appropriately without a risk of stale data.

== Result Sets ==

CQEngine [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html ResultSet]s provide the following methods:

  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html#iterator() iterator()] - Allows the `ResultSet` to be iterated, returning the next object matching the query in each iteration as determined via _lazy evaluation_
    * Result sets support *concurrent iteration* while the collection is being modified; the set of objects returned simply may or may not reflect changes made during iteration (depending on whether changes are made to areas of the collection or indexes already iterated or not)

  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html#uniqueResult() uniqueResult()] - Useful if the query is expected to only match one object, this method returns the first object which would be returned by the iterator, and it throws an exception if more than one object is found

  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html#size() size()] - Returns the number of objects which _would be returned by the `ResultSet` if it was iterated_; CQEngine can often *accelerate* this calculation of size, based on the sizes of individual sets in indexes; see !JavaDoc for details

  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html#contains(O) contains()] -  Tests to see if a _given object_ would be contained in results matching a query; this is also an *accelerated* operation; when suitable indexes are available, CQEngine can avoid iterating results to test for containment; see !JavaDoc for details

  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html#getRetrievalCost() getRetrievalCost()] - This is a metric used internally by CQEngine to allow it to _choose between multiple indexes_ which support the query. This could occasionally be used by applications to ascertain if suitable indexes are available for any particular query, this will be `Integer.MAX_VALUE` for queries for which no suitable indexes are available

  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html#getMergeCost() getMergeCost()] - This is a metric used internally by CQEngine to allow it to _re-order_ elements of the query to minimize time complexity; for example CQEngine will order intersections such that the smallest set drives the _merge_; this metric is _roughly_ based on the theoretical cost to iterate underlying result sets
    * For query fragments requiring _set union_ (`or`-based queries), this will be the _sum_ of merge costs from underlying result sets
    * For query fragments requiring _set intersection_ (`and`-based queries), this will be the _Math.min()_ of merge costs from underlying result sets, because intersections will be re-ordered to perform lowest-merge-cost intersections first
    * For query fragments requiring _set difference_ (`not`-based queries), this will be the merge cost from the first underlying result set

== De-duplicating Results ==

It is possible that a query would result in the same object being returned more than once by the same result set. For example if an object matches several attribute values specified in an `or`-type query, then the object will be returned multiple times, one time for each attribute matched. Intersections (`and`-type queries) do not produce duplicates.

By default, CQEngine *does not* perform de-duplication of results; however it can be instructed to do so, using various strategies, which can be supplied via _query options_.

CQEngine supports the following de-duplication strategies:

*[http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/query/option/DeduplicationStrategy.html#DUPLICATES_ALLOWED Duplicates Allowed Strategy]*

This is the default.

Example usage:
{{{
    QueryOption<Car> deduplication = deduplicate(DeduplicationStrategy.DUPLICATES_ALLOWED);
    ResultSet<Car> results = cars.retrieve(query, queryOptions(deduplication));
}}}

*[http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/query/option/DeduplicationStrategy.html#LOGICAL_ELIMINATION Logical Elimination Strategy]*

Eliminate duplicates using the rules of set theory, without _materializing_ (copying) the results into an intermediate set.

This is best explained as follows:

  * Let ∪ = conventional set union, duplicates are eliminated
  * Let ∪ₐ = union all, union without eliminating duplicates
  * Let – = set difference

Conventional set union, ∪, can be achieved by combining ∪ₐ (union all) with set difference –.

  * A ∪ B ∪ C = (A ∪ₐ (B – A)) ∪ₐ ((C – B) – A)

CQEngine implements this using the following algorithm (using lazy evaluation during iteration):

  # Iterate and return all objects in set A
  # Move on to objects in set B. For each object in set B, check if it is also contained in set A. If not, return it; otherwise skip it
  # Move on to objects in set C. For each object in set C, check if it is contained in set A or set B. If not, return it; otherwise skip it

*Some notes*

  * _If it is known that for a given `or` query, that sets matching the query will be *disjoint*_ (will not contain duplicates), _logical elimination can be disabled at the query fragment level_. To do so, use [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/query/logical/Or.html#Or(java.util.Collection,%20boolean) this] constructor of the `Or` query class.

  * _For `in`-type queries_ (which are equivalent to `or(equal(..), equal(..))`), _logical elimination is disabled by default_. This is because the values supplied for `in` queries all refer to the same attribute, and it is assumed that the application will take care of not supplying nonsense queries containing duplicate values for the same attribute. Note that `MultiValueAttribute`s can complicate this. To prevent logical deduplication being disabled for `in`-type queries, compose the query using nested `or(equal(..), ...)` queries instead.

Example usage:
{{{
    QueryOption<Car> deduplication = deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION);
    ResultSet<Car> results = cars.retrieve(query, queryOptions(deduplication));
}}}

*Characteristics of this strategy*

  * Guarantees that no duplicates will be returned *provided the collection is not modified concurrently*
    * If an object was concurrently removed from set A _after it had already been returned_, it might be returned _again_
  * Has O(_r_ log(_s_)) time complexity (where _r_ is number of result objects matching the query, _s_ is number of sets to be unioned; use of log is a crude approximation; number of tests for containment depends on number of objects in each subsequent set and number of sets in total)
  * Slows iteration slightly
  * Has no significant memory overhead

*[http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/query/option/DeduplicationStrategy.html#MATERIALIZE Materialize Strategy]*

Despite the typical interpretation, this does not materialize all objects up-front. Instead this strategy configures the result set to start returning objects matching the query immediately, and to record during iteration the objects issued so far in a temporary collection. If the query matches the same object more than once, this strategy will use the temporary collection to detect the duplicate, and it will transparently skip it on subsequent encounters.

Example usage:
{{{
    QueryOption<Car> deduplication = deduplicate(DeduplicationStrategy.MATERIALIZE);
    ResultSet<Car> results = cars.retrieve(query, queryOptions(deduplication));
}}}

*Characteristics of this strategy*

  * Guarantees that no duplicates will ever be returned
  * Has O(_r_) time complexity
  * Slows iteration slightly
  * Memory overhead

== Ordering Results ==

By default, CQEngine does not order results; it simply depends on the order it finds objects in the collection or in indexes.

CQEngine can be instructed to order results via query options as follows.

*Order by price descending*
{{{
    ResultSet<Car> results = cars.retrieve(query, queryOptions(orderByDescending(Car.PRICE))
}}}

*Order by price, then number of doors*
{{{
    ResultSet<Car> results = cars.retrieve(query, queryOptions(orderBy(Car.PRICE, Car.DOORS))
}}}

Note that ordering results is relatively expensive, dependent on the number of objects matching the query, and can cause latency in accessing the first object. It requires all results to be materialized into a sorted set up-front _before iteration can begin_. However ordering results also implicitly eliminates duplicates.

== Index Quantization, Granularity, and Continuous Values ==

Quantization involves converting fine-grained or continuous values, to discrete or coarse-grained values. A Quantizer is a _function_ which takes fine-grained values as input, and maps those values to coarse-grained counterparts as its output, by discarding some precision.

Discrete values (e.g. `Integer`, `Long`, `BigInteger`) are values which have only a finite number of possible values, or which have a fixed spacing between possible values. Continuous values (e.g. `Float`, `Double`, `BigDecimal`) are values which do not have fixed spacing and which therefore can have an arbitrarily high precision.

Building indexes on continuous values can be challenging.

Consider a collection of `Car` objects having `Car.price` values `5000.00`, `5000.000001`, `5000.0000011`.

If an index was built on `Car.price` using full precision - `cars.addIndex(NavigableIndex.onAttribute(Car.PRICE))` - it would look like this:
{{{
5000.00 -> { Car{name=A, price=5000.00} }
5000.000001 -> { Car{name=B, price=5000.000001} }
5000.0000011 -> { Car{name=C, price=5000.0000011} }
}}}
This index would contain many entries, consuming a lot of memory, for only minor variations in `Car.price`.

The same index using a quantizer - `cars.addIndex(NavigableIndex.withQuantizerOnAttribute(DoubleQuantizer.withCompressionFactor(1), Car.Price))` - would look like this:
{{{
5000.0 -> { Car{name=A, price=5000.00}, Car{name=B, price=5000.000001}, Car{name=C, price=5000.0000011} }
}}}
Above, _compression factor 1_,  for `DoubleQuantizer`,  means _"truncate everything after the decimal point"_. Compression factor 5, would mean truncate everything after the decimal point AND group every 5 adjacent values in the index into the same entry.

*Retrieving objects from quantized indexes*

CQEngine uses the following algorithm to retrieve objects matching a query from a quantized index:
  # Apply the same quantization function as used to create the index, to values contained in the query
  # Retrieve _candidate sets_ of objects matching the quantized values from the index
  # Apply lazily-evaluated filters to the result set, which when iterated or queried, causes the result set to filter out objects which do not match the _original query_ thus restoring full precision for objects returned
    * For _equality-type_ queries such as `equal` or `in`, apply the filter to all candidate sets matching the query
    * For _range-type_ queries such as `between`, `lessThan`, `greaterThan` as supported by `NavigableIndex`, apply the filter to only the candidate sets at the _ends_ of the range; objects in candidate sets in the middle of the range inherently will not require filtering and can be retrieved at full speed

As such quantization can greatly reduce the memory requirements of indexes, and often without significant CPU overhead.

*Quantizers Provided*

CQEngine provides the following Quantizers:

[http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/IntegerQuantizer.html IntegerQuantizer], [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/LongQuantizer.html LongQuantizer], [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/BigIntegerQuantizer.html BigIntegerQuantizer], [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/FloatQuantizer.html FloatQuantizer], [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/DoubleQuantizer.html DoubleQuantizer], [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/BigDecimalQuantizer.html BigDecimalQuantizer]

Additional Quantizers can be used by implementing the [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/Quantizer.html Quantizer] interface.