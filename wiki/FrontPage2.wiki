#labels Deprecated
CQEngine, Collection Query Engine, is a NoSQL query engine for retrieving objects from Java collections using SQL-like queries, without the overhead of iterating through the collection. Response times are in the order of microseconds.

CQEngine is also easier to use than writing code for conventional iteration; most queries can be written in one line of code.

CQEngine is somewhat similar to [hXXttp://code.google.com/p/lambdaj/ XXLambdaJ] or [http://en.wikipedia.org/wiki/Language_Integrated_Query Microsoft LINQ], but internally it uses indexes, set theory and query plan optimization to process queries, to instead _avoid_ iterating through the collection.

<wiki:toc max_depth="3" />

== The Limits of Iteration ==
The classic way to retrieve objects matching some criteria from a collection, is to iterate through the collection and apply some tests to each object. If the object matches the criteria, then it is added to a result set. This is repeated for every object in the collection.

*Example: Perform a Query via _Naive Iteration_*

This is hugely inefficient, it performs up to 20,000 tests, for a collection of 10,000 cars:
{{{
    public static Collection<Car> getBlueCarsWithFourDoors(Collection<Car> allCars) {
        List<Car> results = new LinkedList<Car>();
        for (Car car : allCars) {
            if (car.getColor().equals(Car.Color.BLUE) && car.getDoors() == 4) {
                results.add(car);
            }
        }
        return results;
    }
}}}
  * It should be clear that performing queries using iteration, is like _performing SQL queries on a database table which does not have any indexes_.

*Time Complexity*

Let number of objects in the collection = _n_. Let number of tests to be applied to each object = _t_. If there were 10,000 objects in the collection and 5 tests to apply to each object, performing the query would require _n_ x _t_ tests, or 50,000 tests in total. Every _additional_ object added to the collection would require _five_ additional tests to be performed. Performance of queries would _degrade_ as additional objects were added, which is not scalable. The [http://en.wikipedia.org/wiki/Time_complexity time complexity] of this (worst case) is O(_n_ _t_).

*_Optimized Iteration_*

In fact, the iteration above could be improved:

  # If it was known that *_fewer cars have four doors than are blue_*, the test for number of doors should be performed *_first_*. That way, Java would short-circuit the `&&` operator and not actually test the color for the majority of cars which did not already have four doors.
  # In most situations, the application will just iterate through the results returned. In that respect, time complexity would be O(_r_ + _nt_), and the method would have _allocated a `LinkedList` needlessly_. A further problem with the approach, is that it *causes latency*, because the _entire result set must be assembled before the first object can be processed_. The method could be further enhanced to accept a `Handler` object, which it would invoke supplying each Car object which matches the criteria. The handler could do whatever the application otherwise would have done inside its iteration loop; yet a `LinkedList` would not be allocated, the first object would be processed as soon as it was encountered, and all objects would be processed in a single pass.
  # An even nicer way to avoid allocating a `LinkedList`, and which would allow the first object to be processed sooner, and yet which would still allow applications to iterate results in the normal way (without supplying a `Handler`), would be for the method to return an `Iterable` object which acted as a _filtered view_ over `allCars`. As the application iterated through the view, the `Iterable` would scan `allCars` for the _next_ matching object. This is known as _lazy evaluation_.

The problem with optimization #1, is that implementing it requires *statistical knowledge* of the makeup of the collection, based on the values of the fields within each `Car` object.
  * Fortunately, *CQEngine maintains statistical information* on the makeup of collections, and in fact will always re-order queries to maximize execution speed.
  * Also fortunately, *CQEngine uses _lazy evaluation_* heavily: the result sets returned by CQEngine are rarely _materialized_, and instead act as a _view_ over the set of objects in the collection which ultimately match the query.
  * Of course, the main problem with the approach above, is that it *uses iteration in the first place*. It would be useful if it could somehow _jump_ to the sets of cars which have four doors, or which are blue, or both, without having to scan the collection at all.

Here is an example of the *performance of CQEngine versus iteration*:
[http://cqengine.googlecode.com/svn/wiki/images/quantized-navigable-index-carid-between.png]

  * CQEngine is *330187.50% faster* than naive iteration
  * CQEngine is *325727.79% faster* than optimized iteration

See the [Benchmark] wiki page for details of this test, and other tests with various types of query.

== CQEngine Overview ==

CQEngine solves the problems above by making it possible to build _indexes_ on the fields of the objects stored in a collection. For example, if many queries retrieve cars from a collection of `Car` objects, based on the value of field `Car.color`, an index could be added on `Car.color`. Subsequently CQEngine could retrieve the set of objects matching any given color _immediately_ with _constant time complexity_ O(_1_). No iteration would be necessary, and performance would not degrade as new cars were added to the collection. CQEngine is additionally programmed with the rules of set theory, allowing it to reorder components of queries to generate efficient query plans.

*Indexing and Query Plan Optimization*

  * *Simple Indexes* can be added to any number of individual fields in a collection of objects, allowing queries on just those fields to be answered in O(_1_) time complexity
  * *Multiple indexes on the same field*  - several index implementations are provided, each optimized for different types of query on the same field - for example equality, numerical range, string starts with etc.
  * *Compound Indexes* can be added which span multiple fields, allowing queries referencing several fields to also be answered in O(_1_) time complexity
  * *Nested Queries* are fully supported, such as the SQL equivalent of "`WHERE color = 'blue' AND(NOT(doors = 2 OR price > 53.00))`"
  * *Standing Query Indexes* can be added; these allow _arbitrarily complex queries_, or _nested query fragments_, to be answered in O(_1_) time complexity, regardless of the number of fields referenced. Large queries containing branches or query fragments for which standing query indexes exist, will automatically benefit from O(_1_) time complexity evaluation of their branches; in total several indexes might be used to accelerate complex queries
  * *Statistical Query Plan Optimization* - when several fields have suitable indexes, CQEngine will use statistical information from the indexes, to internally make a query plan which selects the indexes which can perform the query with minimum time complexity. When some referenced fields have suitable indexes and some do not, CQEngine will use the available indexes first, and will then iterate the smallest possible set of results from those indexes to filter objects for the rest of the query. In those cases time complexity will be greater than O(_1_), but usually significantly less than O(_n_)
  * *Iteration fallback* -  if no suitable indexes are available, CQEngine will evaluate the query via iteration, using lazy evaluation. CQEngine can always evaluate every query, even if no suitable indexes are available. Queries are not coupled with indexes, so indexes can be added after the fact, to speed up existing queries
  * *CQEngine supports full concurrency* and expects that objects will be added to and removed from the collection at runtime; CQEngine will take care of updating all registered indexes in realtime, without impacting the performance of reading threads while updates are taking place. All provided indexes support *lock-free reads*
  * *Type-safe* - nearly all errors in queries result in _compile-time_ errors instead of exceptions at runtime: CQEngine, all indexes, and all queries are strongly typed using generics at both object-level and field-level

== Complete Example ===

In CQEngine applications mostly interact with [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/IndexedCollection.html IndexedCollection], which is an implementation of [http://docs.oracle.com/javase/6/docs/api/java/util/Set.html java.util.Set], and it provides two additional methods:

  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/engine/QueryEngine.html#addIndex(com.googlecode.cqengine.index.Index) addIndex(SomeIndex)] allows indexes to be added to the collection
  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/engine/QueryEngine.html#retrieve(com.googlecode.cqengine.query.Query) retrieve(Query)] accepts a [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/query/Query.html Query] and returns a [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html ResultSet] providing objects matching that query. `ResultSet` implements [http://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html java.lang.Iterable], so accessing results is achieved by iterating the result set

Here is a *complete example* of how to build a collection, add indexes and perform queries. It does not discuss _attributes_, which are discussed below.
{{{
import static com.googlecode.cqengine.query.QueryFactory.*;

public class Introduction {

    public static void main(String[] args) {
        // Create an indexed collection (note: could alternatively use CQEngine.copyFrom() existing collection)...
        IndexedCollection<Car> cars = CQEngine.newInstance();

        // Add some indexes...
        cars.addIndex(NavigableIndex.onAttribute(Car.CAR_ID));
        cars.addIndex(ReversedRadixTreeIndex.onAttribute(Car.NAME));
        cars.addIndex(SuffixTreeIndex.onAttribute(Car.DESCRIPTION));
        cars.addIndex(HashIndex.onAttribute(Car.FEATURES));

        // Add some objects to the collection...
        cars.add(new Car(1, "ford focus", "great condition, low mileage", Arrays.asList("spare tyre", "sunroof")));
        cars.add(new Car(2, "ford taurus", "dirty and unreliable, flat tyre", Arrays.asList("spare tyre", "radio")));
        cars.add(new Car(3, "honda civic", "has a flat tyre and high mileage", Arrays.asList("radio")));

        // -------------------------- Run some queries --------------------------
        System.out.println("Cars whose name ends with 'vic' or whose id is less than 2:");
        Query<Car> query1 = or(endsWith(Car.NAME, "vic"), lessThan(Car.CAR_ID, 2));
        for (Car car : cars.retrieve(query1)) {
            System.out.println(car);
        }

        System.out.println("\nCars whose flat tyre can be replaced:");
        Query<Car> query2 = and(contains(Car.DESCRIPTION, "flat tyre"), equal(Car.FEATURES, "spare tyre"));
        for (Car car : cars.retrieve(query2)) {
            System.out.println(car);
        }

        System.out.println("\nCars which have a sunroof or a radio but are not dirty:");
        Query<Car> query3 = and(in(Car.FEATURES, "sunroof", "radio"), not(contains(Car.DESCRIPTION, "dirty")));
        for (Car car : cars.retrieve(query3)) {
            System.out.println(car);
        }
    }
}
}}}

*Output from the example*

  * _Cars whose name ends with 'vic' or whose id is less than 2:_
{{{
Car{carId=3, name='honda civic', description='has a flat tyre and high mileage', features=[radio]}
Car{carId=1, name='ford focus', description='great condition, low mileage', features=[spare tyre, sunroof]}
}}}

  * _Cars whose flat tyre can be replaced:_
{{{
Car{carId=2, name='ford taurus', description='dirty and unreliable, flat tyre', features=[spare tyre, radio]}
}}}

  * _Cars which have a sunroof or a radio but are not dirty:_
{{{
Car{carId=1, name='ford focus', description='great condition, low mileage', features=[spare tyre, sunroof]}
Car{carId=3, name='honda civic', description='has a flat tyre and high mileage', features=[radio]}
}}}

== Attributes to Read Fields ==

CQEngine needs to access fields inside objects, so that it can build indexes on fields, and retrieve the value of a certain field from any given object.

CQEngine does not use reflection to do this; instead it uses *attributes*, which is a more powerful concept. An attribute is an object which can read the value of a certain field given an object.

Here is an example of how to define an attribute for a Car object, which reads the `Car.carId` field:
{{{
    public static final Attribute<Car, Integer> CAR_ID = new SimpleAttribute<Car, Integer>("carId") {
        public Integer getValue(Car car) { return car.carId; }
    };
}}}
Usually attributes are defined as anonymous `static` `final` objects like this. Supplying the `"carId"` string parameter to the constructor is actually optional, it is not used by the query engine per-se, except it will lead to more informative exception messages.

Since this attribute reads a field from a `Car` object, the usual place to put the attribute is inside the `Car` class - and this makes queries more readable. However it could really be defined in any class, such as `CarAttributes` or similar. The example above is for a *[http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/attribute/SimpleAttribute.html SimpleAttribute]*, which is designed for fields containing only one value.

CQEngine also supports another type of attribute - *[http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/attribute/MultiValueAttribute.html MultiValueAttribute]* - which can read the values of fields which themselves are collections, and so supports building indexes on objects based on things like keywords associated with those objects.

Here is an example of how to define a `MultiValueAttribute` for a `Car` object which reads the values from `Car.features` where that field is a `List<String>`:
{{{
    public static final Attribute<Car, String> FEATURES = new MultiValueAttribute<Car, String>("features") {
        public List<String> getValues(Car car) { return car.features; }
    };
}}}

== Attributes as Functions ==

It can be noted that attributes are only required to return a value given an object. Although most will do so, there is no requirement that an attribute must provide a value by reading a field in the object. As such attributes can be _virtual_, implemented as _functions_.

*Calculated Attributes*

An attribute can *_calculate_* an appropriate value for an object, based on a function applied to data contained in other fields or from external data sources.

Here is an example for a calculated attribute:
{{{
    public static final Attribute<Car, Boolean> IS_DIRTY = new SimpleAttribute<Car, Boolean>("is_dirty") {
        public Boolean getValue(Car car) { return car.description.contains("dirty"); }
    };
}}}

A `HashIndex` could be built on the virtual attribute above, which would enable fast retrievals of cars which are either dirty or not dirty, without needing to scan the collection.

*Associations with other `IndexedCollections` or External Data Sources*

Here is an example for a virtual attribute which *associates* with each `Car` a list of locations which can service it, from an external data source:
{{{
    public static final Attribute<Car, String> SERVICE_LOCATIONS = new MultiValueAttribute<Car, String>() {
        public List<String> getValues(Car car) {
            return CarServiceManager.getServiceLocationsForCar(car);
        }
    };
}}}
The attribute above would allow the `IndexedCollection` of cars to be searched for cars which have _servicing options in a particular location_.

The locations which service a car, could alternatively be retrieved from another `IndexedCollection`, of `Garage`s, for example. *Care should be taken if building indexes on virtual attributes* however, if referenced data might change leaving obsolete information in indexes. A *strategy to accommodate this* is: if no index exists for a virtual attribute referenced in a query, and other attributes are also referenced in the query for which indexes exist, CQEngine will automatically reduce the candidate set of objects to the minimum using other indexes before querying the virtual attribute. In turn if virtual attributes perform retrievals from _other_ `IndexedCollection`s, then those collections could be indexed appropriately without a risk of stale data.

== Result Sets ==

CQEngine returns 
== Indexing Continuous Values / Index Granularity / Quantization ==

Quantization involves converting fine-grained or continuous values, to discrete or coarse-grained values. A Quantizer is a _function_ which takes fine-grained values as input, and maps those values to coarse-grained counterparts as its output, by discarding some precision.

Discrete values (e.g. `Integer`, `Long`, `BigInteger`) are values which have only a finite number of possible values, or which have a fixed spacing between possible values. Continuous values (e.g. `Float`, `Double`, `BigDecimal`) are values which do not have fixed spacing and which therefore can have an arbitrarily high precision.

Building indexes on continuous values can be challenging.

Consider a collection of `Car` objects having `Car.price` values `5000.00`, `5000.000001`, `5000.0000011`.

If an index was built on `Car.price` using full precision - `cars.addIndex(NavigableIndex.onAttribute(Car.PRICE))` - it would look like this:
{{{
5000.00 -> { Car{name=A, price=5000.00} }
5000.000001 -> { Car{name=B, price=5000.000001} }
5000.0000011 -> { Car{name=C, price=5000.0000011} }
}}}
This index would contain many entries, consuming a lot of memory, for only minor variations in `Car.price`.

The same index using a quantizer - `cars.addIndex(NavigableIndex.withQuantizerOnAttribute(DoubleQuantizer.withCompressionFactor(1), Car.Price))` - would look like this:
{{{
5000.0 -> { Car{name=A, price=5000.00}, Car{name=B, price=5000.000001}, Car{name=C, price=5000.0000011} }
}}}
Above, _compression factor 1_,  for `DoubleQuantizer`,  means _"truncate everything after the decimal point"_. Compression factor 5, would mean truncate everything after the decimal point AND group every 5 adjacent values in the index into the same entry.

*Retrieving objects from quantized indexes*

CQEngine uses the following algorithm to retrieve objects matching a query from a quantized index:
  # Apply the same quantization function as used to create the index, to values contained in the query
  # Retrieve _candidate sets_ of objects matching the quantized values from the index
  # Apply lazily-evaluated filters to the result set, which when iterated or queried, causes the result set to filter out objects which do not match the _original query_ thus restoring full precision for objects returned
    * For equality-based lookups, apply the filter to all candidate sets matching the query
    * For _range-type_ queries such as `between`, `lessThan`, `greaterThan` as supported by `NavigableIndex`, apply the filter to only the candidate sets at the _ends_ of the range; objects in candidate sets in the middle of the range inherently will not require filtering and can be retrieved at full speed

As such quantization can greatly reduce the memory requirements of indexes, and often without significant CPU overhead.

*Quantizers Provided*

CQEngine provides the following Quantizers:
  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/IntegerQuantizer.html IntegerQuantizer]
  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/LongQuantizer.html LongQuantizer]
  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/BigIntegerQuantizer.html BigIntegerQuantizer]
  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/FloatQuantizer.html FloatQuantizer]
  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/DoubleQuantizer.html DoubleQuantizer]
  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/BigDecimalQuantizer.html BigDecimalQuantizer]

Additional Quantizers can be used by implementing the [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/quantizer/Quantizer.html Quantizer] interface.