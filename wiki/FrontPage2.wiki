#labels Deprecated
CQEngine, Collection Query Engine, is a NoSQL query engine for retrieving objects from Java collections using SQL-like queries, without the overhead of iterating through the collection. The engine is extremely fast and more scalable than conventional iteration; response times are in the order of microseconds.

CQEngine is also more intuitive and easier to use than writing code for conventional iteration; most queries can be written in one line of code.

CQEngine is somewhat similar to [hXXttp://code.google.com/p/lambdaj/ XXLambdaJ] or [http://en.wikipedia.org/wiki/Language_Integrated_Query Microsoft LINQ], but internally it uses indexes, set theory and query plan optimization to process queries, to instead _avoid_ iterating through the collection.

<wiki:toc max_depth="3" />

== The problem with Iteration ==
The classic way to retrieve objects matching some criteria from a collection, is to iterate through the collection and apply some tests to each object. If the object matches the criteria, then it is added to a result set. This is repeated for every object in the collection.

*Example: Perform a Query via _Naive Iteration_*

This is hugely inefficient, it performs up to 20,000 tests, for a collection of 10,000 cars:
{{{
    public static Collection<Car> getBlueCarsWithFourDoors(Collection<Car> allCars) {
        List<Car> results = new LinkedList<Car>();
        for (Car car : allCars) {
            if (car.getColor().equals(Car.Color.BLUE) && car.getDoors() == 4) {
                results.add(car);
            }
        }
        return results;
    }
}}}
  * It should be clear that performing queries using iteration, is like _performing SQL queries on a database table which does not have any indexes_.

*Time Complexity*

Let number of objects in the collection = _n_. Let number of tests to be applied to each object = _t_. If there were 10,000 objects in the collection and 5 tests to apply to each object, performing the query would require _n_ x _t_ tests, or 50,000 tests in total.

For every _additional_ object added to the collection, _five_ additional tests would need to be performed. As such the performance of queries would _degrade steeply_ as additional objects were added. This is not scalable. The [http://en.wikipedia.org/wiki/Time_complexity time complexity] of this iteration approach (worst case) is O(_n_ _t_).

*_Optimized Iteration_*

In fact, the iteration above could be improved:

  # If it was known that _fewer cars have 4 doors than are blue_, the test for number of doors should be performed _first_. That way, Java would short-circuit the `&&` operator and not actually test the color for the majority of cars which did not already have four doors.
  # In most situations, the application which calls this method, will just iterate through the results returned. In that respect, time complexity would be O(_2_ _n_ _t_), and the method would have _allocated a `LinkedList` needlessly_. A further problem with the approach, is that it *causes latency*, because the _entire result set must be assembled before the first object can be processed_. The method could be further enhanced to accept a `Handler` object, which it would invoke supplying each Car object which matches the criteria. The handler could do whatever the application otherwise would have done inside its iteration loop; yet a `LinkedList` would not have been allocated, the first object would be processed as soon as it was encountered, and all objects would be processed in a single pass.
  # An even nicer way to avoid allocating a `LinkedList`, and which would allow the first object to be processed sooner, and yet which would still allow applications to iterate results in the normal way (without supplying a `Handler`), would be for the method to return an `Iterable` object which acted as a _filtered view_ over `allCars`. As the application iterated through the view, the `Iterable` would scan `allCars` for the _next_ matching object. This is known as _lazy evaluation_.

The problem with optimization #1, is that implementing it requires *statistical knowledge* of the makeup of the collection, based on the values of the fields within each `Car` object.
  * Fortunately, *CQEngine maintains statistical information* on the makeup of collections, and in fact will always re-order queries to maximize execution speed.
  * Also fortunately, *CQEngine uses _lazy evaluation_* heavily: the result sets returned by CQEngine are rarely _materialized_, and instead act as a _view_ over the set of objects in the collection which ultimately match the query.
  * Of course, the main problem with the approach above, is that it *uses iteration in the first place*. It would be useful if it could somehow _jump_ to the sets of cars which have four doors, or which are blue, or both, without having to scan the collection at all.

== CQEngine Approach ==

CQEngine solves the problems above by making it possible to build _indexes_ on the fields of the objects stored in a collection. For example, if many queries retrieve cars from a collection of `Car` objects, based on the value of field `Car.color`, an index could be added on `Car.color`. Subsequently CQEngine could retrieve the set of objects matching any given color _immediately_ with _constant time complexity_ O(_1_). No iteration would be necessary, and performance would not degrade as new cars were added to the collection. CQEngine is additionally programmed with the rules of set theory, allowing it to reorder components of queries to generate efficient query plans.

*Indexing and Query Plan Optimization*

  * *Simple Indexes* can be added to any number of individual fields in a collection of objects, allowing queries on just those fields to be answered in O(_1_) time complexity
  * *Multiple indexes can be added to the same field*  - several index implementations are provided, each optimized for different types of query on the same field - for example equality, numerical range, string starts with etc.
  * *Compound Indexes* can be added which span multiple fields, allowing queries referencing several fields to also be answered in O(_1_) time complexity
  * *Nested Queries* are fully supported, such as the SQL equivalent of "`WHERE color = 'blue' AND(NOT(doors = 2 OR price > 53.00))`"
  * *Standing Query Indexes* can be added; these allow _arbitrarily complex queries_, or _nested query fragments_, to be answered in O(_1_) time complexity, regardless of the number of fields referenced. Large queries containing branches or query fragments for which standing query indexes exist, will automatically benefit from O(_1_) time complexity evaluation of their branches; in total several indexes might be used to accelerate complex queries
  * *Query Plan Optimization* - when several fields have suitable indexes, CQEngine will use statistical information from the indexes, to internally make a query plan which selects the indexes which can perform the query with minimum time complexity. When some referenced fields have suitable indexes and some do not, CQEngine will use the available indexes first, and will then iterate the smallest possible set of results from those indexes to filter objects for the rest of the query. In those cases time complexity will be greater than O(_1_), but usually significantly less than O(_n_)
  * *Iteration fallback* -  if no suitable indexes are available, CQEngine will evaluate the query via iteration, using lazy evaluation. CQEngine can always evaluate every query, even if no suitable indexes are available. Queries are not coupled with indexes, so indexes can be added after the fact, to speed up existing queries
  * *CQEngine supports full concurrency* and expects that objects will be added to and removed from the collection at runtime; CQEngine will take care of updating all registered indexes in realtime, without impacting the performance of reading threads while updates are taking place

== Example Usage ===

Applications mostly interact with [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/IndexedCollection.html IndexedCollection]. This is an implementation of [http://docs.oracle.com/javase/6/docs/api/java/util/Set.html java.util.Set] (so it can be used as a normal collection), and it also provides the following methods:

  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/engine/QueryEngine.html#addIndex(com.googlecode.cqengine.index.Index) IndexecCollection.addIndex(SomeIndex)] allows indexes to be added to the collection
  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/engine/QueryEngine.html#retrieve(com.googlecode.cqengine.query.Query) IndexedCollection.retrieve(Query)] accepts a [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/query/Query.html Query] and returns a [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html ResultSet] providing objects matching that query. `ResultSet` implements [http://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html java.lang.Iterable], so accessing results is achieved by iterating the result set

Here is a *complete example* which demonstrates how indexed collections are used. It does not discuss _attributes_, which are discussed below.
{{{
import static com.googlecode.cqengine.query.QueryFactory.*;

public class Introduction {

    public static void main(String[] args) {
        // Create an indexed collection (note: could alternatively use CQEngine.copyFrom() existing collection)...
        IndexedCollection<Car> cars = CQEngine.newInstance();

        // Add some indexes...
        cars.addIndex(NavigableIndex.onAttribute(Car.CAR_ID));
        cars.addIndex(ReversedRadixTreeIndex.onAttribute(Car.NAME));
        cars.addIndex(SuffixTreeIndex.onAttribute(Car.DESCRIPTION));
        cars.addIndex(HashIndex.onAttribute(Car.FEATURES));

        // Add some objects to the collection...
        cars.add(new Car(1, "ford focus", "great condition, low mileage", Arrays.asList("spare tyre", "sunroof")));
        cars.add(new Car(2, "ford taurus", "dirty and unreliable, flat tyre", Arrays.asList("spare tyre", "radio")));
        cars.add(new Car(3, "honda civic", "has a flat tyre and high mileage", Arrays.asList("radio")));

        // -------------------------- Run some queries --------------------------
        System.out.println("Cars whose name ends with 'vic' or whose id is less than 2:");
        Query<Car> query1 = or(endsWith(Car.NAME, "vic"), lessThan(Car.CAR_ID, 2));
        for (Car car : cars.retrieve(query1)) {
            System.out.println(car);
        }

        System.out.println("\nCars whose flat tyre can be replaced:");
        Query<Car> query2 = and(contains(Car.DESCRIPTION, "flat tyre"), equal(Car.FEATURES, "spare tyre"));
        for (Car car : cars.retrieve(query2)) {
            System.out.println(car);
        }

        System.out.println("\nCars which have a sunroof or a radio but are not dirty:");
        Query<Car> query3 = and(in(Car.FEATURES, "sunroof", "radio"), not(contains(Car.DESCRIPTION, "dirty")));
        for (Car car : cars.retrieve(query3)) {
            System.out.println(car);
        }
    }
}
}}}

*Output from the example*
{{{
Cars whose name ends with 'vic' or whose id is less than 2:
Car{carId=3, name='honda civic', description='has a flat tyre and high mileage', features=[radio]}
Car{carId=1, name='ford focus', description='great condition, low mileage', features=[spare tyre, sunroof]}

Cars whose flat tyre can be replaced:
Car{carId=2, name='ford taurus', description='dirty and unreliable, flat tyre', features=[spare tyre, radio]}

Cars which have a sunroof or a radio but are not dirty:
Car{carId=1, name='ford focus', description='great condition, low mileage', features=[spare tyre, sunroof]}
Car{carId=3, name='honda civic', description='has a flat tyre and high mileage', features=[radio]}
}}}

== Attributes ==

CQEngine needs to access fields inside objects, so that it can build indexes on fields, and retrieve the value of a certain field from any given object.

CQEngine does not use reflection to do this; instead it uses *attributes*, which is a more powerful concept. An attribute is an object which can read the value of a certain field given an object of the relevant type.

Here is an example of how to define an attribute for a Car object, which reads the `Car.carId` field:
{{{
    public static final Attribute<Car, Integer> CAR_ID = new SimpleAttribute<Car, Integer>("carId") {
        public Integer getValue(Car car) { return car.carId; }
    };
}}}
Usually attributes are defined as anonymous `static` `final` objects like this. Supplying the `"carId"` string parameter to the constructor is actually optional, it is not used by the query engine per-se, except it will lead to more informative exception messages.

Since this attribute reads a field from a `Car` object, the usual place to put the attribute is inside the `Car` class - and this makes queries more readable. However it could really be defined in any class, such as `CarAttributes` or similar. The example above is for a *[http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/attribute/SimpleAttribute.html SimpleAttribute]*, which is designed for fields containing only one value.

CQEngine also supports another type of attribute - *[http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/attribute/MultiValueAttribute.html MultiValueAttribute]* - which can read the values of fields which themselves are collections, and so supports building indexes on objects based on things like keywords associated with those objects.

Here is an example of how to define a `MultiValueAttribute` for a `Car` object which reads the values from `Car.features` where that field is a `List<String>`:
{{{
    public static final Attribute<Car, String> FEATURES = new MultiValueAttribute<Car, String>("features") {
        public List<String> getValues(Car car) { return car.features; }
    };
}}}

*Attribute as Functions*

It can be noted that attributes are only required to return a value given an object. Although most will do so, there is no requirement that an attribute must provide a value by reading a field in the object. As such attributes can be implemented as _functions_, which can _calculate_ an appropriate value for an object; or which can return a value for the object based on an _association with another collection_.