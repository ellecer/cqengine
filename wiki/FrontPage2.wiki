#labels Deprecated
CQEngine, Collection Query Engine, is a NoSQL query engine for retrieving objects from Java collections using SQL-like queries, without the overhead of iterating through the collection. The engine is extremely fast and more scalable than conventional iteration; response times are in the order of microseconds.

CQEngine is also more intuitive and easier to use than writing code for conventional iteration; most queries can be written in one line of code.

CQEngine is somewhat similar to [hXXttp://code.google.com/p/lambdaj/ XXLambdaJ] or [http://en.wikipedia.org/wiki/Language_Integrated_Query Microsoft LINQ], but internally it uses indexes, set theory and query plan optimization to process queries, to instead _avoid_ iterating through the collection.

<wiki:toc max_depth="3" />

== The problem with Iteration ==
The classic way to retrieve objects matching some criteria from a collection, is to iterate through the collection and apply some tests to each object. If the object matches the criteria, then it is added to a result set. This is repeated for every object in the collection.

*Example: Perform a Query via _Naive Iteration_*

This is hugely inefficient, it performs up to 20,000 tests, for a collection of 10,000 cars:
{{{
    public static Collection<Car> getBlueCarsWithFourDoors(Collection<Car> allCars) {
        List<Car> results = new LinkedList<Car>();
        for (Car car : allCars) {
            if (car.getColor().equals(Car.Color.BLUE) && car.getDoors() == 4) {
                results.add(car);
            }
        }
        return results;
    }
}}}
  * It should be clear that performing queries using iteration, is like _performing SQL queries on a database table which does not have any indexes_.

*Time Complexity*

Let number of objects in the collection = _n_. Let number of tests to be applied to each object = _t_. If there were 10,000 objects in the collection and 5 tests to apply to each object, performing the query would require _n_ x _t_ tests, or 50,000 tests in total.

For every _additional_ object added to the collection, _five_ additional tests would need to be performed. As such the performance of queries would _degrade steeply_ as additional objects were added. This is not scalable. The [http://en.wikipedia.org/wiki/Time_complexity time complexity] of this iteration approach (worst case) is O(_n_ _t_).

*_Optimized Iteration_*

In fact, the iteration above could be improved:

  # If it was known that _fewer cars have 4 doors than are blue_, the test for number of doors should be performed _first_. That way, Java would short-circuit the `&&` operator and not actually test the color for the majority of cars which did not already have four doors.
  # In most situations, the application which calls this method, will just iterate through the results returned. In that respect, time complexity would be O(_2_ _n_ _t_), and the method would have _allocated a `LinkedList` needlessly_. A further problem with the approach, is that it *causes latency*, because the _entire result set must be assembled before the first object can be processed_. The method could be further enhanced to accept a `Handler` object, which it would invoke supplying each Car object which matches the criteria. The handler could do whatever the application otherwise would have done inside its iteration loop; yet a `LinkedList` would not have been allocated, the first object would be processed as soon as it was encountered, and all objects would be processed in a single pass.
  # An even nicer way to avoid allocating a `LinkedList`, and which would allow the first object to be processed sooner, and yet which would still allow applications to iterate results in the normal way (without supplying a `Handler`), would be for the method to return an `Iterable` object which acted as a _filtered view_ over `allCars`. As the application iterated through the view, the `Iterable` would scan `allCars` for the _next_ matching object. This is known as _lazy evaluation_.

The problem with optimization #1, is that implementing it requires *statistical knowledge* of the makeup of the collection, based on the values of the fields within each `Car` object.
  * Fortunately, *CQEngine maintains statistical information* on the makeup of collections, and in fact will always re-order queries to maximize execution speed.
  * Also fortunately, *CQEngine uses _lazy evaluation_* heavily: the result sets returned by CQEngine are rarely _materialized_, and instead act as a _view_ over the set of objects in the collection which ultimately match the query.
  * Of course, the main problem with the approach above, is that it *uses iteration in the first place*. It would be useful if it could somehow _jump_ to the sets of cars which have four doors, or which are blue, or both, without having to scan the collection at all.

== CQEngine Approach ==

CQEngine solves the problems above by making it possible to build _indexes_ on the fields of the objects stored in a collection. For example, if many queries retrieve cars from a collection of `Car` objects, based on the value of field `Car.color`, an index could be added on `Car.color`. Subsequently CQEngine could retrieve the set of objects matching any given color _immediately_ with _constant time complexity_ O(_1_). No iteration would be necessary, and performance would not degrade as new cars were added to the collection. CQEngine is additionally programmed with the rules of set theory, allowing it to reorder components of queries to generate efficient query plans.

*Indexing and Query Plan Optimization*

  * *Simple Indexes* can be added to any number of individual fields in a collection of objects, allowing queries on just those fields to be answered in O(_1_) time complexity
  * *Multiple indexes can be added to the same field*  - several index implementations are provided, each optimized for different types of query on the same field - for example equality, numerical range, string starts with etc.
  * *Compound Indexes* can be added which span multiple fields, allowing queries referencing several fields to also be answered in O(_1_) time complexity
  * *Nested Queries* are fully supported, such as the SQL equivalent of "`WHERE color = 'blue' AND(NOT(doors = 2 OR price > 53.00))`"
  * *Standing Query Indexes* can be added; these allow _arbitrarily complex queries_, or _nested query fragments_, to be answered in O(_1_) time complexity, regardless of the number of fields referenced. Large queries containing branches or query fragments for which standing query indexes exist, will automatically benefit from O(_1_) time complexity evaluation of their branches; in total several indexes might be used to accelerate complex queries
  * *Query Plan Optimization* - when several fields have suitable indexes, CQEngine will use statistical information from the indexes, to internally make a query plan which selects the indexes which can perform the query with minimum time complexity. When some referenced fields have suitable indexes and some do not, CQEngine will use the available indexes first, and will then iterate the smallest possible set of results from those indexes to filter objects for the rest of the query. In those cases time complexity will be greater than O(_1_), but usually significantly less than O(_n_)
  * *Iteration fallback* -  if no suitable indexes are available, CQEngine will evaluate the query via iteration, using lazy evaluation. CQEngine can always evaluate every query, even if no suitable indexes are available. Queries are not coupled with indexes, so indexes can be added after the fact, to speed up existing queries
  * *CQEngine supports full concurrency* and expects that objects will be added to and removed from the collection at runtime; CQEngine will take care of updating all registered indexes in realtime, without impacting the performance of reading threads while updates are taking place

== Usage Overview ===

Applications mostly interact with [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/IndexedCollection.html IndexedCollection]. This is an implementation of [http://docs.oracle.com/javase/6/docs/api/java/util/Set.html java.util.Set] (so it can be used as a normal collection), and it also provides the following methods:

  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/engine/QueryEngine.html#addIndex(com.googlecode.cqengine.index.Index) IndexecCollection.addIndex(SomeIndex)] allows indexes to be added to the collection
  * [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/engine/QueryEngine.html#retrieve(com.googlecode.cqengine.query.Query) IndexedCollection.retrieve(Query)] accepts a [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/query/Query.html Query] and returns a [http://cqengine.googlecode.com/svn/cqengine/javadoc/apidocs/com/googlecode/cqengine/resultset/ResultSet.html ResultSet] providing objects matching that query. ResultSet implements [http://docs.oracle.com/javase/6/docs/api/java/lang/Iterable.html java.lang.Iterable], so accessing results is achieved by iterating the result set

*Complete Example*

Continuing with the Car analogy...

{{{
public class Car {
    public final int carId;
    public final String manufacturer;
    public final String model;

    public Car(int carId, String manufacturer, String model) {
        this.carId = carId;
        this.manufacturer = manufacturer;
        this.model = model;
    }

    @Override
    public String toString() {
        return "Car{carId=" + carId + ", manufacturer='" + manufacturer + "', model='" + model + "'}";
    }

    // -------------------------- Attributes --------------------------
    public static final Attribute<Car, Integer> CAR_ID = new SimpleAttribute<Car, Integer>("carId") {
        public Integer getValue(Car car) { return car.carId; }
    };

    public static final Attribute<Car, String> MANUFACTURER = new SimpleAttribute<Car, String>("manufacturer") {
        public String getValue(Car car) { return car.manufacturer; }
    };

    public static final Attribute<Car, String> MODEL = new SimpleAttribute<Car, String>("model") {
        public String getValue(Car car) { return car.model; }
    };
}
}}}