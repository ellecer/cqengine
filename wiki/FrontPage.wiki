#labels Deprecated
CQEngine is a NoSQL database engine for performing SQL-like queries on standard Java collections, with the goal of returning results _faster than iteration would allow_. Response times are in the order of _microseconds_.

CQEngine is somewhat similar to [http://en.wikipedia.org/wiki/Language_Integrated_Query Microsoft LINQ], or [http://code.google.com/p/lambdaj/ LambdaJ for Java], but internally CQEngine uses indexing and set theory rather than iteration to process queries.

== Iteration versus Indexing and Query Plan Optimization ==
=== Iteration ===
The classic way to retrieve objects matching some criteria from a collection, is to iterate through the collection and apply some tests to each object. If the object matches the criteria, then it is added to a result set. This is repeated for every object in the collection.

Lets call the number of objects in the collection _n_. Lets call the number of tests to be applied to each object _t_. If there were 10,000 objects in the collection (_n_ = 10,000) and 5 tests to apply to each object (_t_ = 5), then performing the query would require _n_ x _t_ tests, or 50,000 tests to be applied to the collection in total. For every _additional_ object added to the collection, _five_ additional tests would need to be performed. As such the performance of queries would degrade steeply as additional objects were added. The [http://en.wikipedia.org/wiki/Time_complexity time complexity] of this iteration approach is O(_n_ _t_).

This is hugely inefficient, it performs up to 20,000 tests, for a collection of 10,000 cars:
{{{
    public static Collection<Car> getBlueCarsWithFourDoors(Collection<Car> allCars) {
        List<Car> results = new LinkedList<Car>();
        for (Car candidate : allCars) {
            if (candidate.getColor().equals(Car.Color.BLUE) && candidate.getDoors() == 4) {
                results.add(candidate);
            }
        }
        return results;
    }
}}}
It should be clear that performing queries using iteration, is like _performing SQL queries on a database table which does not have any indexes_.

*In fact, the iteration above could be improved:*

  # If it was known that _fewer cars have 4 doors than are blue_, the test for number of doors should be performed _first_. That way, Java would short-circuit the `&&` statement and not actually test the color for the majority of cars which did not already have four doors.
  # In most situations, the application which calls this method, will just iterate through the results returned. In that respect, the method would have allocated a `LinkedList` needlessly. The method could be further enhanced to accept a `Handler` object, which it would invoke supplying each Car object which matches the criteria. The handler could do whatever the application otherwise would have done inside its iteration loop; yet a `LinkedList` would not have been allocated.
  # An even nicer way to avoid allocating a `LinkedList`, and yet which would still allow applications to iterate results in the normal way (without supplying a `Handler`), would be for the method to return an `Iterable` object which acted as a _filtered view_ over `allCars`. As the application iterated through the view, the `Iterable` would scan `allCars` for the _next_ matching object. This is known as _lazy evaluation_.

The problem with optimization #1, is that implementing it requires *statistical knowledge* of the makeup of the collection, based on the values of the fields within each `Car` object.
  * Fortunately, *CQEngine maintains statistical information* on the makeup of collections, and in fact will always re-order queries to maximize execution speed.
  * Also fortunately, CQEngine uses _lazy evaluation_ heavily: the result sets returned by CQEngine are rarely _materialized_, and instead act as a _view_ over the set of objects in the collection which ultimately match the query.

=== Indexing and Query Plan Optimization in CQEngine ===
In CQEngine, it is possible to build indexes on the fields of the objects stored in a collection. For example, if many queries retrieve products from a collection of `Product` objects, based on the value of field `Product.price`, an index could be added on `Product.price`. Subsequently CQEngine could retrieve the set of objects matching any given price _immediately_ with _constant time complexity_ O(1). No iteration would be necessary, and performance would not degrade as new products were added to the collection.

In CQEngine:
  * *Simple Indexes* can be added to any number of individual fields in a collection of objects, allowing queries on just those fields to be answered in O(1) time complexity
  * *Multiple indexes can be added to the same field*  - several index implementations are provided, each optimized for different types of query on the same field - for example equality, numerical range, string starts with etc.
  * *Compound Indexes* can be added which span multiple fields, allowing queries referencing several fields to also be answered in O(1) time complexity
  * *Standing Query Indexes* can be added; these allow _arbitrarily complex queries_ to be answered in O(1) time complexity, regardless of the number of fields referenced
  * *Query Plan Optimization* - when several fields have suitable indexes, CQEngine will use statistical information from the indexes, to internally make a query plan which selects the indexes which can perform the query with minimum time complexity. When some referenced fields have suitable indexes and some do not, CQEngine will use the available indexes first, and will then iterate the smallest possible set of results from those indexes to filter objects for the rest of the query
  * *Iteration fallback* -  if no suitable indexes are available, CQEngine will evaluate the query via iteration. CQEngine can always evaluate every query, even if no suitable indexes are available. Queries are not coupled with indexes, so indexes can be added after the fact, to speed up existing queries
  * *CQEngine supports full concurrency* and expects that objects will be added to and removed from the collection at runtime; CQEngine will take care of updating all registered indexes in realtime, without impacting the performance of reading threads while updates are taking place

== Performance and Time Complexity ==
To compare the performance of CQEngine versus iteration, let's consider an example.

Let's assume we have an online car dealership. The dealership has a website with a catalogue of 100,000 cars. So it has a collection of `Car` objects. Every car object has a number of fields containing the price, manufacturer, model, number of doors etc. For the purpose of the example, let's ignore setter and getter methods, and assume Cars are immutable.
{{{
public class Car {
    enum Color {RED, GREEN, BLUE, BLACK, WHITE}
    public final int carId;
    public final String manufacturer;
    public final String model;
    public final Color color;
    public final int doors;
    public final double price;

    public Car(int carId, String manufacturer, String model, Color color, int doors, double price) {
        this.carId = carId;
        this.manufacturer = manufacturer;
        this.model = model;
        this.color = color;
        this.doors = doors;
        this.price = price;
    }
}
}}}

For the sake of the example, let's say the collection of Cars is created by the following method:
{{{
    public static Set<Car> createCollectionOfCars(int numCars) {
        Set<Car> cars = new LinkedHashSet<Car>(numCars);
        for (int carId = 0; carId < numCars; carId++) {
            final Car car;
            switch (carId % 10) {
                case 0: car = new Car(carId, "Ford",   "Focus",   Car.Color.RED,   5, 5000.00); break;
                case 1: car = new Car(carId, "Ford",   "Fusion",  Car.Color.RED,   4, 3999.99); break;                    
                case 2: car = new Car(carId, "Ford",   "Taurus",  Car.Color.GREEN, 4, 6000.00); break;                    
                case 3: car = new Car(carId, "Honda",  "Civic",   Car.Color.WHITE, 5, 4000.00); break;                    
                case 4: car = new Car(carId, "Honda",  "Accord",  Car.Color.BLACK, 5, 3000.00); break;                    
                case 5: car = new Car(carId, "Honda",  "Insight", Car.Color.GREEN, 3, 5000.00); break;                    
                case 6: car = new Car(carId, "Toyota", "Avensis", Car.Color.GREEN, 5, 5999.95); break;                    
                case 7: car = new Car(carId, "Toyota", "Prius",   Car.Color.BLUE,  3, 8500.00); break;                    
                case 8: car = new Car(carId, "Toyota", "Hilux",   Car.Color.RED,   5, 7800.55); break;                    
                case 9: car = new Car(carId, "BMW",    "M6",      Car.Color.BLUE,  2, 9000.23); break;                    
                default: throw new IllegalStateException();
            }
            cars.add(car);
        }
        return cars;
    }
}}}

As such, some statistics about the collection:
|| *Color (aka Colour :)* || *% of cars* || *Manufacturer* || *% of cars* || *Number of doors* || *% of cars* ||
|| Red || 30% || Ford || 30% || 5 || 50% ||
|| Green || 30% || Honda || 30% || 4 || 20% ||
|| Blue || 20% || Toyota || 30% || 3 || 20% ||
|| Black || 10% || BMW || 10% || 2 || 10% ||
|| White || 10% ||  ||  || || ||


|| Cars which are green and are manufactured by Ford || 10% ||
|| Cars which are blue and have 3 doors || 10% ||